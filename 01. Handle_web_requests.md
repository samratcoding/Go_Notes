
# cURL Command Options

cURL is a command-line tool used for transferring data with URLs. Below is a table of common cURL options and their meanings.

## cURL Options Table

| Option | Description |
|--------|-------------|
| `-X GET` | Sends a **GET** request (default). |
| `-X POST` | Sends a **POST** request (for sending data). |
| `-X PUT` | Sends a **PUT** request (for updating data). |
| `-X DELETE` | Sends a **DELETE** request (for deleting resources). |
| `HTTP/1.1` | Protocol Version HTTP |
| `Host ` | Endpoint |
| `-H "Header-Name: value"` | Adds a custom **header** to the request. |
| `x-api-key: YOUR_API_KEY` | Example custom **header** to the request. |
| `-d 'data'` | Sends **data** in the request body. |
| `{ "text": "Your input text" }` | Another example of **data** in the request body. |
| `-F 'key=value'` | Sends **form data** (useful for file uploads). |
| `-o output.txt` | Saves the response to **output.txt** instead of printing it. |
| `-i` | Displays **response headers** in the output. |
| `-v` | Shows **detailed request and response logs** (useful for debugging). |
| `-L` | Follows **redirects** (useful when a URL redirects to another). |
| `-u username:password` | Uses **Basic Authentication** (not recommended for sensitive data). |
| `--data-urlencode 'field=value'` | Sends **URL-encoded data** (useful for APIs that require it). |
| `-b cookies.txt` | Sends cookies stored in `cookies.txt` with the request. |
| `-c cookies.txt` | Saves cookies from the response to `cookies.txt`. |
| `--compressed` | Requests a **compressed response** (e.g., gzip). |
| `--retry N` | Retries the request **N times** in case of failure. |
| `-s` | **Silent mode** (hides progress and error messages). |
| `--http2` | Uses **HTTP/2** instead of HTTP/1.1. |
| `--max-time SECONDS` | Sets a maximum **timeout** for the request. |
| `--head` | Fetches **only headers**, without the response body. |

## Example Usage

### Simple GET Request
```sh
curl -X GET "https://api.example.com/data"
```

### POST Request with JSON Data
```sh
curl -X POST "https://api.example.com/submit" \
     -H "Content-Type: application/json" \
     -d '{"name": "John", "age": 30}'
```

### File Upload
```sh
curl -X POST "https://api.example.com/upload" \
     -F "file=@document.pdf"
```

For more details, check the [official cURL documentation](https://curl.se/docs/).

---

# HTTP Request Methods in Go

This document explains two primary ways to make HTTP requests in Go (`http.Post` and `http.NewRequest`) and discusses when to use each, how to prepare data, and handle other HTTP methods like GET, DELETE, PUT, and session/cookie management.

---

## Table of Contents
1. [Using `http.Post`](#using-http-post)
2. [Using `http.NewRequest`](#using-http-newrequest)
3. [Comparison: `http.Post` vs `http.NewRequest`](#comparison-http-post-vs-http-newrequest)
4. [Handling Other HTTP Methods](#handling-other-http-methods)
   - GET
   - PUT
   - DELETE
5. [Passing Cookies and Sessions](#passing-cookies-and-sessions)
6. [Best Practices](#best-practices)

---

## Using `http.Post`
[Return Table of Content](#Table-of-Contents)
`http.Post` is a simplified way to send HTTP POST requests.

### Example
```go
url := "https://api.example.com/endpoint"
requestBody, err := json.Marshal(map[string]string{
    "key": "value",
})
if err != nil {
    log.Fatal(err)
}

response, err := http.Post(url, "application/json", bytes.NewBuffer(requestBody))
if err != nil {
    log.Fatal(err)
}

defer response.Body.Close()
body, err := io.ReadAll(response.Body)
if err != nil {
    log.Fatal(err)
}

fmt.Println(string(body))
```

### Key Points
- **Data Preparation**: Marshal the request body into JSON or use `strings.NewReader` for raw text.
- **Headers**: You cannot customize headers directly. Use `http.NewRequest` if header customization is required.

### When to Use
- When making simple POST requests with no need for custom headers or advanced configurations.

---

## Using `http.NewRequest`
[Return Table of Content](#Table-of-Contents)
`http.NewRequest` offers more flexibility, allowing you to customize headers, HTTP methods, and more.

### Example
```go
url := "https://api.example.com/endpoint"
requestBody, err := json.Marshal(map[string]string{
    "key": "value",
})
if err != nil {
    log.Fatal(err)
}

req, err := http.NewRequest("POST", url, bytes.NewBuffer(requestBody))
if err != nil {
    log.Fatal(err)
}

req.Header.Set("Content-Type", "application/json")
req.Header.Set("x-api-key", "your-api-key")

client := &http.Client{}
response, err := client.Do(req)
if err != nil {
    log.Fatal(err)
}

defer response.Body.Close()
body, err := io.ReadAll(response.Body)
if err != nil {
    log.Fatal(err)
}

fmt.Println(string(body))
```

### Key Points
- **Data Preparation**: Same as `http.Post`.
- **Headers**: Set custom headers with `req.Header.Set`.
- **HTTP Client**: Use the `http.Client` to execute the request.

### When to Use
- When you need custom headers, query parameters, or advanced configurations.

---

## Comparison: `http.Post` vs `http.NewRequest`
[Return Table of Content](#Table-of-Contents)
| Feature                    | `http.Post`                     | `http.NewRequest`                |
|----------------------------|----------------------------------|-----------------------------------|
| Ease of Use                | Simple                          | More complex                     |
| Custom Headers             | Not supported                   | Fully supported                  |
| HTTP Methods               | Only POST                       | Any method (GET, PUT, DELETE, etc.) |
| Advanced Configurations    | Not supported                   | Fully supported                  |

---

## Handling Other HTTP Methods
[Return Table of Content](#Table-of-Contents)
### GET
```go
url := "https://api.example.com/resource"
req, err := http.NewRequest("GET", url, nil)
if err != nil {
    log.Fatal(err)
}

client := &http.Client{}
response, err := client.Do(req)
if err != nil {
    log.Fatal(err)
}

defer response.Body.Close()
body, err := io.ReadAll(response.Body)
if err != nil {
    log.Fatal(err)
}

fmt.Println(string(body))
```

### PUT
[Return Table of Content](#Table-of-Contents)
```go
url := "https://api.example.com/resource"
requestBody := bytes.NewBuffer([]byte(`{"key": "new-value"}`))
req, err := http.NewRequest("PUT", url, requestBody)
if err != nil {
    log.Fatal(err)
}
req.Header.Set("Content-Type", "application/json")

client := &http.Client{}
response, err := client.Do(req)
if err != nil {
    log.Fatal(err)
}

defer response.Body.Close()
fmt.Println("Resource updated successfully")
```

### DELETE
[Return Table of Content](#Table-of-Contents)
```go
url := "https://api.example.com/resource"
req, err := http.NewRequest("DELETE", url, nil)
if err != nil {
    log.Fatal(err)
}

client := &http.Client{}
response, err := client.Do(req)
if err != nil {
    log.Fatal(err)
}

defer response.Body.Close()
fmt.Println("Resource deleted successfully")
```

---

## Passing Cookies and Sessions
[Return Table of Content](#Table-of-Contents)
You can pass cookies and maintain sessions by using a `http.Client` with a `CookieJar`.

### Example
```go
import (
    "net/http"
    "net/http/cookiejar"
)

jar, _ := cookiejar.New(nil)
client := &http.Client{
    Jar: jar,
}

url := "https://api.example.com/login"
requestBody := bytes.NewBuffer([]byte(`{"username": "user", "password": "pass"}`))

req, err := http.NewRequest("POST", url, requestBody)
if err != nil {
    log.Fatal(err)
}
req.Header.Set("Content-Type", "application/json")

response, err := client.Do(req)
if err != nil {
    log.Fatal(err)
}

defer response.Body.Close()

// The client will automatically store and send cookies for subsequent requests.
fmt.Println("Logged in successfully")
```

---

## Best Practices
[Return Table of Content](#Table-of-Contents)
1. **Error Handling**: Always handle errors at each step to avoid runtime crashes.
2. **Reuse HTTP Client**: Use a single `http.Client` instance for better performance.
3. **Timeouts**: Set timeouts for the `http.Client` to prevent hanging requests.
4. **Security**: Avoid hardcoding sensitive data like API keys in code. Use environment variables instead.
5. **Logging**: Log responses for debugging, but sanitize sensitive information.

---

This document provides a concise yet detailed overview of making HTTP requests in Go. Use the method that best suits your application's requirements.
